# 초읽기(Byoyomi) 시스템 구현 가이드

이 문서는 Pair Go 프로젝트의 초읽기 시스템이 백엔드와 프론트엔드에서 어떻게 동작하는지 설명합니다. 효율적인 리소스 사용과 정확한 시간 동기화를 위해 **"서버 권한(Server Authority) 및 클라이언트 예측(Client Prediction)"** 패턴을 사용합니다.

---

## 1. 기본 개념 및 전략

### 핵심 철학

- **서버는 "심판"입니다.** 정확한 남은 시간을 관리하고, 시간이 다 되었을 때 판정을 내리는 역할만 수행합니다. 매 초마다 시간을 클라이언트에게 알려주지 않습니다.
- **클라이언트는 "시계"입니다.** 서버가 알려준 "마지막 착수 시간"을 기준으로 스스로 계산하여 사용자에게 남은 시간을 보여줍니다.

### 용어 정의

- **기본 시간 (Basic Time)**: 게임 시작 시 주어지는 총 생각 시간입니다. 소진되면 초읽기로 넘어갑니다.
- **초읽기 (Byoyomi)**: 기본 시간을 모두 쓴 후 주어지는 짧은 시간입니다. (예: 30초 3회)
  - 정해진 시간(30초) 안에 착수하면 횟수가 줄어들지 않고 시간이 다시 30초로 초기화됩니다.
  - 시간을 넘기면 횟수가 1회 차감되며, 횟수가 0이 되면 시간패(Time Out)합니다.

---

## 2. 데이터 구조

### 핵심 데이터 (GameInstance)

시간 계산을 위해 서버와 클라이언트는 다음 데이터를 공유합니다.

1.  **`lastMoveTime` (타임스탬프)**: 가장 최근에 돌에 놓인 시각 (서버 기준 `Date.now()`). 모든 시간 계산의 기준점입니다.
2.  **`remainingBasicTimeMs`**: 해당 플레이어에게 남은 총 기본 시간.
3.  **`remainingByoyomiTimeMs`**: 초읽기 1회당 주어지는 시간 (설정값).
4.  **`remainingByoyomiPeriods`**: 남은 초읽기 기회 횟수.

---

## 3. 백엔드 로직 (Server)

백엔드는 `setTimeout`을 사용하여 효율적으로 시간을 관리합니다.

### 1) 턴 시작 시 (Timer Start)

플레이어의 차례가 되면 서버는 즉시 "알람"을 맞춥니다.

- **기본 시간이 남았을 때**: `남은 기본 시간` 뒤에 울리도록 알람 설정.
- **초읽기 상태일 때**: `초읽기 시간(예: 30초)` 뒤에 울리도록 알람 설정.
- _참고: 이 알람은 단 하나만 존재하므로 서버 리소스 소모가 매우 적습니다._

### 2) 플레이어가 착수했을 때 (Move Process)

알람이 울리기 전에 플레이어가 돌을 두면 다음 과정을 수행합니다.

1.  **기존 알람 해제**: 맞춰두었던 시간 초과 알람을 끕니다.
2.  **시간 차감 (기본 시간인 경우만)**: `(현재 시간 - lastMoveTime)`만큼 기본 시간을 줄입니다. 초읽기 중이라면 시간을 차감하지 않습니다 (초읽기는 성공/실패 여부만 중요).
3.  **기준점 갱신**: `lastMoveTime`을 현재 시간으로 업데이트합니다.
4.  **다음 턴 알람 설정**: 다음 플레이어를 위한 새로운 알람을 맞춥니다.
5.  **정보 전송**: 변경된 시간 정보와 `lastMoveTime`을 클라이언트에게 보냅니다.

### 3) 시간이 초과되었을 때 (Timeout Handler)

플레이어가 착수하지 못하고 알람이 울리면 서버는 다음과 같이 처리합니다.

- **기본 시간 종료 시**:
  - 플레이어의 상태를 "초읽기"로 변경합니다.
  - `byoyomiStart` 이벤트를 발생시켜 클라이언트가 효과음을 재생하게 합니다.
  - 즉시 초읽기 시간(예: 30초)으로 새로운 알람을 맞춥니다.
- **초읽기 시간 종료 시**:
  - 초읽기 횟수(`byoyomiPeriods`)를 1 차감합니다.
  - **횟수가 남아있다면**:
    - `byoyomiPeriodUsed` 이벤트를 발생시켜 횟수 차감을 알립니다.
    - `timeUpdate` 이벤트를 전송하여 시간 정보를 갱신합니다.
    - 다시 초읽기 시간으로 알람을 맞추고 게임을 진행합니다.
  - **횟수가 0이라면**:
    - **시간패(TimeWin)** 처리합니다.
    - `gameEnded` 이벤트를 전송하여 결과를 알립니다 (`{ type: 'TimeWin', winner: ... }`).

---

## 4. 프론트엔드 로직 (Client)

클라이언트는 서버의 데이터를 받아 화면에 그리는 역할과, 사용자에게 긴박감을 주는 역할을 합니다.

### 1) 시간 표시 (Visual Countdown)

서버에서 1초마다 신호를 주지 않으므로, 클라이언트가 직접 계산해야 합니다.

- `requestAnimationFrame` 또는 짧은 간격의 `setInterval`을 사용합니다.
- **계산 공식**:
  ```text
  경과 시간 = (현재 클라이언트 시간) - (서버에서 받은 lastMoveTime)
  보여줄 시간 = (서버에서 받은 남은 시간) - (경과 시간)
  ```
- 이렇게 하면 네트워크가 끊겨도 화면의 타이머는 부드럽게 계속 내려갑니다.

### 2) 초읽기 UI 및 사운드

- **초읽기 진입**: 서버로부터 `byoyomiStart` 이벤트를 받으면 "초읽기를 시작합니다" 음성을 재생하고, UI를 초읽기 모드(예: 빨간색 강조)로 변경합니다.
- **초읽기 소진**: `byoyomiPeriodUsed` 이벤트를 받으면 "하나 공제했습니다" 알림 및 차감 UI를 갱신합니다.
- **카운트다운 음성**: 클라이언트 스스로 남은 시간을 계산하다가, 10초, 5초, 1초 등 특정 시점에 도달하면 음성(TTS 등)을 재생합니다.

### 3) 동기화 (Sync)

- **착수 시 (`moveMade`)**: 누군가 돌을 두면 서버에서 `moveMade` 이벤트가 옵니다. 보드 상태를 갱신하고 타이머를 다음 턴 기준으로 리셋합니다.
- **시간 갱신 시 (`timeUpdate`)**: 착수 없이 시간만 변경된 경우(초읽기 전환 등) 서버에서 `timeUpdate`가 옵니다. 타이머 기준점(`lastMoveTime`)을 다시 동기화합니다.
- **게임 종료 (`gameEnded`)**: `TimeWin` 또는 `Resignation` 등의 결과가 담긴 이벤트를 수신하면 게임을 멈추고 결과를 표시합니다.

---

## 5. 전체 흐름 요약

1.  **[Game Start]**: 서버가 `lastMoveTime`을 찍고 게임 시작 알림.
2.  **[Client]**: `lastMoveTime`을 기준으로 타이머가 줄어드는 애니메이션 재생.
3.  **[Event]**: 사용자 착수 (돌 놓음).
4.  **[Server]**:
    - 시간 계산: `현재 - lastMoveTime` 만큼 차감.
    - 기존 타이머 취소.
    - 새 `lastMoveTime` 갱신.
    - 상대방을 위한 새 타이머(`setTimeout`) 설정.
    - 결과 전송 (`moveMade`).
5.  **[Server - Timeout]**: 사용자가 착수 안 함 -> `setTimeout` 발동.
    - 기본 시간이면 -> 초읽기 모드 전환 -> `byoyomiStart` 전송 -> `timeUpdate`.
    - 초읽기 중이면 -> 횟수 차감 (`byoyomiPeriodUsed`) -> `timeUpdate` OR 게임 종료 (`gameEnded`).

이 구조를 통해 서버 부하를 최소화하면서도, 0.1초 단위의 정밀한 타이머 경험을 제공할 수 있습니다.
